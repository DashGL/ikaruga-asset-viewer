---
title: NJ Model Format
description: Guide for viewing and understanding NJ (Ninja) 3D models
---

import NJViewer from '../../../components/NjViewer';

# Ninja (NJ) 3D Model Format

The Ninja format (NJ) is a proprietary 3D model format used by Sega, particularly on the Dreamcast console. The format was created by Sega AM2 for their "Ninja" game engine, which was used for many Dreamcast titles.

## Format Overview

Ninja models typically have the following structure:

- A header section containing format information
- A bone/skeleton hierarchy for animated models
- Vertex data (positions, normals, UVs)
- Material and texture references
- Triangle/strip data for rendering

Files typically have the `.nj` extension (model data) or may come with paired `.njm` files (animation data).

## Viewing 3D Models

Below is an example of a 3D model viewer rendering a Ninja format model:

<NJViewer
  client:load
  modelPath="OBJ/COCK.NJ"
  texturePaths={["OBJ/COCK.PVM"]}
  width={600}
  height={400}
/>

## Format Details

### File Structure

The NJ format uses a chunk-based structure with different sections indicated by 4-character codes like:

- `NJTL` - Texture list
- `NJCM` - Model data (vertex, polygon, material)
- `NMDM` - Animation data

### NJTL (Texture List)

The NJTL chunk contains a list of texture names referenced by the model. It uses a pointer-based structure to efficiently store and access texture references.

#### Memory Layout

```
NJTL Chunk Structure:
+-------------------------+
| "NJTL" Magic (4 bytes)  |
+-------------------------+
| Chunk Size (4 bytes)    |
+-------------------------+
| Pointer to tex list     | ---+
+-------------------------+    |
| Number of textures      |    |
+-------------------------+    |
|         ...             |    |
+-------------------------+    |
|                         |    |
|                         |    |
+-------------------------+    |
|                         | <--+
| Texture List:           |
|   - Name Pointer 1      | ---> "texture1.pvr"
|   - Attributes (8 bytes)|
|   - Name Pointer 2      | ---> "texture2.pvr"
|   - Attributes (8 bytes)|
|   ...                   |
+-------------------------+
| Texture Names:          |
|   "texture1.pvr\0"      |
|   "texture2.pvr\0"      |
|   ...                   |
+-------------------------+
```

The texture list is read in a multi-step process:
1. Store the current position as a reference point
2. Read the pointer to the texture list and number of textures
3. Seek to the texture list (pointer + reference position)
4. Read all texture name pointers (and skip additional data)
5. For each pointer, seek to the actual texture name and read the string

Here's the actual implementation code that parses the NJTL section:

```typescript
const readNjtl = (reader: ByteReader): string[] => {
  // Store current position as reference point
  const ref = reader.tell();

  // Read pointer to texture list and count
  const ptr = reader.readUInt32();
  const count = reader.readUInt32();

  // Seek to texture list
  reader.seek(ptr + ref);

  // Read all texture name pointers
  const textureNamePointers: number[] = [];
  for (let i = 0; i < count; i++) {
    textureNamePointers.push(reader.readUInt32());
    reader.seekRel(8); // Skip additional data (8 bytes)
  }

  // Read actual texture names
  const textureNames: string[] = [];
  textureNamePointers.forEach((ptr) => {
    reader.seek(ref + ptr);
    const name = reader.readString();
    textureNames.push(name);
  });

  return textureNames;
};
```

This approach allows the model to reference textures stored in separate files. The returned texture names are typically used to locate and load the corresponding textures needed for rendering the model.

#### Texture Names in Ikaruga

In Ikaruga, the texture names stored in NJTL chunks do not include file extensions (like .PVR). These names reference textures that are typically stored within PVM files (which are collections of PVR textures). For example, a texture name like "COCK" would reference a texture within the corresponding PVM file (e.g., COCK.PVM).

The NJ model renderer needs to:
1. Extract the texture name from the NJTL chunk
2. Locate the corresponding texture within the PVM collection
3. Apply the texture to the appropriate mesh parts

This naming convention allows the same model to work with different texture formats while maintaining the same internal references.

### Bone Hierarchy

Models can contain a hierarchical bone structure for animation:

- Bones are organized in a parent-child relationship
- Each bone has position, rotation, and scale information
- Bones can have mesh data attached to them

### Vertex Format

Vertex data includes:
- 3D position (x, y, z)
- Normal vectors
- Texture coordinates (UVs)
- Color information
- Skinning weights (for animated models)

### Materials

Material definitions include:
- Texture references
- Diffuse, specular, and ambient colors
- Alpha/transparency settings
- Various render flags

## Technical Implementation

The model viewer uses Three.js with React Three Fiber to render the 3D models in the browser. The implementation:

1. Loads and parses the NJ file format
2. Extracts bone hierarchy, vertex data, and material information
3. Loads associated textures from PVM/PVR files
4. Creates a Three.js skinned mesh with the appropriate materials
5. Renders the model with interactive controls for rotating and zooming
